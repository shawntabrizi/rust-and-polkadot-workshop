diff --git a/src/balances.rs b/src/balances.rs
index 34debc2..b0b3191 100644
--- a/src/balances.rs
+++ b/src/balances.rs
@@ -34,7 +34,10 @@ impl<T: Config> Pallet<T> {
 	pub fn balance(&self, who: &T::AccountId) -> T::Balance {
 		*self.balances.get(who).unwrap_or(&T::Balance::zero())
 	}
+}
 
+/* TODO: Add the `#[macros::call]` attribute right here. */
+impl<T: Config> Pallet<T> {
 	/// Transfer `amount` from one account to another.
 	/// This function verifies that `from` has at least `amount` balance to transfer,
 	/// and that no mathematical overflows occur.
@@ -60,12 +63,14 @@ impl<T: Config> Pallet<T> {
 // A public enum which describes the calls we want to expose to the dispatcher.
 // We should expect that the caller of each call will be provided by the dispatcher,
 // and not included as a parameter of the call.
+/* TODO: Remove `enum Call`, this is being generated automatically by `#[macros::call]`. */
 pub enum Call<T: Config> {
 	Transfer { to: T::AccountId, amount: T::Balance },
 }
 
 /// Implementation of the dispatch logic, mapping from `BalancesCall` to the appropriate underlying
 /// function we want to execute.
+/* TODO: Remove this `Dispatch` impl, this is also being generated by `#[macros::call]`. */
 impl<T: Config> crate::support::Dispatch for Pallet<T> {
 	type Caller = T::AccountId;
 	type Call = Call<T>;
diff --git a/src/main.rs b/src/main.rs
index 60b086a..ee9ea1d 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -122,10 +122,12 @@ fn main() {
 		extrinsics: vec![
 			support::Extrinsic {
 				caller: &"alice",
+				/* TODO: Update the enum name to match what is generated with the macro. */
 				call: RuntimeCall::Balances(balances::Call::Transfer { to: &"bob", amount: 20 }),
 			},
 			support::Extrinsic {
 				caller: &"alice",
+				/* TODO: Update the enum name to match what is generated with the macro. */
 				call: RuntimeCall::Balances(balances::Call::Transfer {
 					to: &"charlie",
 					amount: 20,
